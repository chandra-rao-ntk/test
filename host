#!/usr/bin/env python3
# Read-only PAN workflow (IPs + Names, multi-VR, aligned, always list all FWs)
# - Panorama: objects/rules per IP OR name prefix (supports groups that contain those names)
# - Firewalls: one session per FW; run FIB for ALL resulting IPs across ALL VRs; cache interface->zone
# - Shows ALL FWs; star (★) rows whose DG has rules for the object/group
# - Per-session logs + stitched report in ./logs/

import os, re, time, logging, datetime as dt
from concurrent.futures import ThreadPoolExecutor, as_completed
from netmiko import ConnectHandler, NetmikoTimeoutException, NetmikoAuthenticationException

# ========= USER SETTINGS =========
USERNAME = "admin"
PASSWORD = "REPLACE_ME"

# You can provide **both** IPs and name bases
IPS_TO_CHECK = [
    "10.232.64.10",
    # "10.212.64.10",
]

# e.g. "qvapp800" will match qvapp800, qvapp800-1, qvapp800_2, ...
NAMES_TO_CHECK = [
    # "qvapp800",
]

PANORAMA_HOST = "10.232.240.150"

FIREWALLS = {
    "10.232.240.151": "FBAS21INFW001",
    "10.232.240.161": "FBAS21NPFW001",
    "10.232.240.155": "FBAS21PAFW001",
    "10.232.240.159": "FBAS21PRFW001",
    "10.232.240.153": "FBAS21SSFW001",
    "10.232.240.157": "FBAS21VPFW001",
    "10.212.240.151": "FBCH03INFW001",
    "10.212.240.161": "FBCH03NPFW001",
    "10.212.240.155": "FBCH03PAFW001",
    "10.212.240.159": "FBCH03PRFW001",
    "10.212.240.153": "FBCH03SSFW001",
    "10.212.240.157": "FBCH03VPFW001",
}

# OPTIONAL Panorama template overrides (mgmt_ip -> template name)
TEMPLATE_OVERRIDE = {
    # "10.232.240.151": "FBAS21INFW_Template",
}

# Force some FWs to always try these VRs (union with Panorama; forced first)
FORCE_FW_VRS = {
    "10.232.240.157": ["INT_VR", "EXT_VR"],  # FBAS21VPFW001
    "10.212.240.157": ["INT_VR", "EXT_VR"],  # FBCH03VPFW001
}

# Device-group -> firewall mgmt IPs (for ★ marking)
DG_TO_FIREWALLS = {
    "FBAS21INFW": ["10.232.240.151"],
    "FBAS21NPFW": ["10.232.240.161"],
    "FBAS21PAFW": ["10.232.240.155"],
    "FBAS21PRFW": ["10.232.240.159"],
    "FBAS21SSFW": ["10.232.240.153"],
    "FBAS21VPFW": ["10.232.240.157"],
    "FBCH03INFW": ["10.212.240.151"],
    "FBCH03NPFW": ["10.212.240.161"],
    "FBCH03PAFW": ["10.212.240.155"],
    "FBCH03PRFW": ["10.212.240.159"],
    "FBCH03SSFW": ["10.212.240.153"],
    "FBCH03VPFW": ["10.212.240.157"],
}

# Concurrency and logging
MAX_WORKERS = 6
LOG_DIR = "./logs"
ENABLE_NETMIKO_DEBUG = True
os.makedirs(LOG_DIR, exist_ok=True)
if ENABLE_NETMIKO_DEBUG:
    logging.basicConfig(
        filename=os.path.join(LOG_DIR, "netmiko_debug.log"),
        level=logging.DEBUG,
        format="%(asctime)s %(levelname)s %(name)s: %(message)s",
    )
    logging.getLogger("netmiko").setLevel(logging.DEBUG)

# ---------- helpers ----------
def _session_log_path(host: str, kind: str) -> str:
    ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S_%f")
    return os.path.join(LOG_DIR, f"{kind}_{host.replace(':','_')}_{ts}.session.log")

def _write_log(fname: str, text: str):
    try:
        with open(os.path.join(LOG_DIR, fname), "w", encoding="utf-8") as f:
            f.write(text)
    except Exception:
        pass

def _clean_iface(tok: str) -> str:
    return tok.strip().strip(",;:")

def name_matches(base: str, candidate: str) -> bool:
    b = base.lower()
    c = candidate.lower()
    return c == b or c.startswith(b + "-") or c.startswith(b + "_") or c.startswith(b)

# ---------- Netmiko connect ----------
def connect_panos(host, title="", retries=1):
    info = {
        "device_type": "paloalto_panos",
        "host": host,
        "username": USERNAME,
        "password": PASSWORD,
        "fast_cli": False,
        "global_delay_factor": 1.0,
        "session_log": _session_log_path(host, "panorama" if host == PANORAMA_HOST else "fw"),
        "banner_timeout": 90,
        "auth_timeout": 60,
        "conn_timeout": 30,
        "use_keys": False,
        "allow_agent": False,
    }
    last_err = None
    for attempt in range(retries + 1):
        try:
            conn = ConnectHandler(**info)
            conn.send_command("set cli config-output-format set", expect_string=r">|#")
            conn.send_command("set cli pager off", expect_string=r">|#")
            conn.send_command("set cli terminal width 999", expect_string=r">|#")
            return conn
        except (NetmikoTimeoutException, NetmikoAuthenticationException, Exception) as e:
            last_err = e
            if attempt < retries:
                time.sleep(2)
            else:
                raise RuntimeError(f"Failed to connect to {title or host}: {e}")

# ---------- Panorama lookups ----------
def pano_addr_objs_for_ip(conn, ip):
    conn.config_mode()
    out = conn.send_command(f"show | match {ip}", expect_string=r"#", read_timeout=90)
    conn.exit_config_mode()
    objs, seen = [], set()
    for s in out.splitlines():
        s = s.strip()
        if not (s.startswith("set ") and " address " in s and " ip-netmask " in s and ip in s):
            continue
        parts = s.split()
        if parts[1] == "shared" and parts[2] == "address":
            name, scope = parts[3], "shared"
        elif parts[1] == "device-group":
            dg = parts[2]
            name = parts[parts.index("address") + 1]
            scope = f"device-group {dg}"
        else:
            continue
        key = (name, scope)
        if key not in seen:
            seen.add(key)
            objs.append({"name": name, "scope": scope})
    if not objs:
        _write_log(f"pano_show_match_{ip}.txt", out)
    return objs

def pano_find_by_name_prefix(conn, base):
    """
    Find address OBJECTS whose names start with <base> and collect their IPs,
    and any address-GROUPS that statically include those names.
    Returns: dict with:
      { "objects": [{"name", "scope", "ip"}...],
        "groups":  [{"name", "scope"}...] }
    """
    conn.config_mode()
    out = conn.send_command(f"show | match {base}", expect_string=r"#", read_timeout=120)
    conn.exit_config_mode()

    objs = []
    groups = []
    seen_obj = set()
    seen_grp = set()

    for s in out.splitlines():
        s = s.strip()
        if not s.startswith("set "):
            continue
        parts = s.split()

        # Address objects with ip-netmask
        if " address " in s and " ip-netmask " in s:
            try:
                if parts[1] == "shared" and parts[2] == "address":
                    name, scope = parts[3], "shared"
                    ip = parts[-1]
                elif parts[1] == "device-group":
                    dg = parts[2]
                    idx = parts.index("address")
                    name = parts[idx + 1]
                    ip = parts[-1]
                    scope = f"device-group {dg}"
                else:
                    continue
                if name_matches(base, name):
                    key = (name, scope)
                    if key not in seen_obj:
                        seen_obj.add(key)
                        objs.append({"name": name, "scope": scope, "ip": ip})
            except Exception:
                continue

        # Address-groups (static) containing potential members
        if " address-group " in s and " static " in s and "[" in s and "]" in s:
            try:
                # tokens inside [...]
                inside = s.split("[", 1)[1].rsplit("]", 1)[0]
                members = [t.strip(",") for t in inside.split()]
                group_name = None
                if parts[1] == "shared" and "address-group" in parts:
                    group_name = parts[parts.index("address-group")+1]
                    scope = "shared"
                elif parts[1] == "device-group":
                    dg = parts[2]
                    group_name = parts[parts.index("address-group")+1]
                    scope = f"device-group {dg}"
                if group_name and any(name_matches(base, m) for m in members):
                    key = (group_name, scope)
                    if key not in seen_grp:
                        seen_grp.add(key)
                        groups.append({"name": group_name, "scope": scope})
            except Exception:
                continue

    return {"objects": objs, "groups": groups}

def pano_rules_for_token(conn, token_name):
    """Find rules referencing this object or group name."""
    conn.config_mode()
    out = conn.send_command(f"show | match {token_name}", expect_string=r"#", read_timeout=120)
    conn.exit_config_mode()
    refs, seen = [], set()
    for s in out.splitlines():
        s = s.strip()
        if not s.startswith("set device-group ") or " security rules " not in s or f" {token_name} " not in f" {s} ":
            continue
        parts = s.split()
        try:
            dg     = parts[2]
            where  = parts[3]
            rule   = parts[parts.index("rules") + 1]
            field  = "source" if " source " in f" {s} " else ("destination" if " destination " in f" {s} " else "unknown")
            key    = (token_name, dg, where, rule, field)
            if key not in seen:
                seen.add(key)
                refs.append({"obj": token_name, "dg": dg, "where": where, "rule": rule, "field": field})
        except Exception:
            continue
    return refs

def pano_template_vrs(conn):
    conn.config_mode()
    out = conn.send_command(
        'show | match "set template " | match " vsys vsys1 import network virtual-router "',
        expect_string=r"#", read_timeout=90,
    )
    conn.exit_config_mode()
    mapping = {}
    for line in out.splitlines():
        s = line.strip()
        if not s.startswith("set template ") or " vsys vsys1 import network virtual-router " not in s:
            continue
        parts = s.split()
        tmpl = parts[2]
        tail = s.split("virtual-router", 1)[1].strip()
        if tail.startswith("["):
            inside = tail.strip("[]").strip()
            vrs = [tok.strip(",") for tok in inside.split() if tok not in ("[", "]")]
        else:
            vrs = [tail.split()[0].strip(",")]
        mapping.setdefault(tmpl, [])
        for vr in vrs:
            if vr and vr not in mapping[tmpl]:
                mapping[tmpl].append(vr)
    if not mapping:
        _write_log("pano_template_vrs_raw.txt", out)
    return mapping

def heuristic_template_name(fw_name: str) -> str:
    base = re.sub(r"\d+$", "", fw_name)
    return f"{base}_Template"

def build_fw_to_vrs_from_panorama(conn):
    tmpl_vrs = pano_template_vrs(conn)
    fw_to_vrs = {}
    for mgmt_ip, fw_name in FIREWALLS.items():
        tmpl = TEMPLATE_OVERRIDE.get(mgmt_ip, heuristic_template_name(fw_name))
        vrs = tmpl_vrs.get(tmpl, [])
        forced = FORCE_FW_VRS.get(mgmt_ip, [])
        vrs = forced + [vr for vr in vrs if vr not in forced]
        fw_to_vrs[mgmt_ip] = vrs
    return fw_to_vrs

# ---------- Firewall ops ----------
def discover_vrs_on_fw(conn):
    vrs = set()
    out1 = conn.send_command("show routing summary", read_timeout=30)
    for line in out1.splitlines():
        m = re.search(r"\bvirtual[-\s]?router\s+([A-Za-z0-9._-]+)", line, re.IGNORECASE)
        if m: vrs.add(m.group(1))
    if not vrs:
        conn.config_mode()
        out2 = conn.send_command('show | match "set network virtual-router "', expect_string=r"#", read_timeout=60)
        conn.exit_config_mode()
        for line in out2.splitlines():
            parts = line.strip().split()
            if len(parts) >= 4 and parts[:3] == ["set", "network", "virtual-router"]:
                vrs.add(parts[3])
    if not vrs:
        vrs.add("default")
    return sorted(vrs)

def fib_try(conn, vr, ip):
    out = conn.send_command(f"test routing fib-lookup virtual-router {vr} ip {ip}", read_timeout=45)
    first, selected = None, None
    for raw in out.splitlines():
        line = raw.strip()
        if "interface " in line:
            try:
                iface = _clean_iface(line.split("interface", 1)[1].split()[0])
            except Exception:
                continue
            if first is None:
                first = iface
            if "[selected]" in line:
                selected = iface
    return selected or first

def fib_lookup_multi_all_vrs(conn, ips, vrs):
    if not vrs:
        vrs = discover_vrs_on_fw(conn)
    results = {ip: [] for ip in ips}
    for ip in ips:
        seen = set()
        for vr in vrs:
            iface = fib_try(conn, vr, ip)
            key = (vr, iface or "<none>")
            if key in seen:
                continue
            seen.add(key)
            results[ip].append((vr, iface))
    return results

def get_zone_for_interface(conn, fw_host: str, interface: str):
    if not interface:
        return None
    cmd1 = f"show interface {interface} | match Zone"
    out1 = conn.send_command(cmd1, read_timeout=30)
    for line in out1.splitlines():
        s = line.strip()
        if s.lower().startswith("zone"):
            return s.split(":", 1)[-1].strip().split(",", 1)[0].strip()
    cmd2 = f"show interface {interface} | match zone"
    out2 = conn.send_command(cmd2, read_timeout=30)
    for line in out2.splitlines():
        s = line.strip()
        if s.lower().startswith("zone"):
            return s.split(":", 1)[-1].strip().split(",", 1)[0].strip()
    conn.config_mode()
    cmd3 = f"show | match zone | match {interface}"
    out3 = conn.send_command(cmd3, expect_string=r"#", read_timeout=60)
    conn.exit_config_mode()
    for s in out3.splitlines():
        s = s.strip()
        if s.startswith("set ") and " zone " in s and interface in s:
            try:
                return s.split(" zone ", 1)[1].split()[0]
            except Exception:
                pass
    _write_log(f"{fw_host}_zone_debug_{interface}.txt",
               f"$ {cmd1}\n{out1}\n\n$ {cmd2}\n{out2}\n\n$ {cmd3}\n{out3}\n")
    return None

def fw_worker_all_ips(fw_ip, fw_name, ip_list, pano_vrs_for_fw):
    out = {}
    try:
        fw = connect_panos(fw_ip, fw_name, retries=1)
        vr_pairs = fib_lookup_multi_all_vrs(fw, ip_list, pano_vrs_for_fw)
        zone_cache = {}
        for ip in ip_list:
            rows = []
            for vr, iface in vr_pairs.get(ip, []):
                if iface:
                    zone = zone_cache.get(iface)
                    if zone is None:
                        zone = get_zone_for_interface(fw, fw_ip, iface) or "<not-found>"
                        zone_cache[iface] = zone
                    rows.append({"fw": fw_name, "ip": fw_ip, "vr": vr,
                                 "iface": iface, "zone": zone, "err": ""})
                else:
                    rows.append({"fw": fw_name, "ip": fw_ip, "vr": vr,
                                 "iface": "<not-found>", "zone": "<not-found>", "err": ""})
            if not rows:
                rows.append({"fw": fw_name, "ip": fw_ip, "vr": "<unknown>",
                             "iface": "<not-found>", "zone": "<not-found>", "err": ""})
            out[ip] = rows
        fw.disconnect()
        return out
    except Exception as e:
        for ip in ip_list:
            out[ip] = [{"fw": fw_name, "ip": fw_ip, "vr": "<error>",
                        "iface": "<error>", "zone": "<error>", "err": str(e)}]
        return out

# ---------- stars, table, report ----------
def dgs_for_rule_refs(rule_refs): return {r["dg"] for r in rule_refs}

def starred_fw_ips_from_dgs(rule_dgs):
    starred = set()
    for dg in rule_dgs:
        starred.update(DG_TO_FIREWALLS.get(dg, []))
    return starred

def format_table(rows, starred_ips):
    disp = []
    for r in rows:
        star = "★" if r["ip"] in starred_ips else " "
        disp.append({
            "fw": f"{star} {r['fw']}",
            "ip": r["ip"],
            "vr": r["vr"],
            "iface": r["iface"],
            "zone": r["zone"],
            "err": r.get("err", ""),
        })
    fw_w = max(20, max(len(x["fw"]) for x in disp))
    ip_w = max(15, max(len(x["ip"]) for x in disp))
    vr_w = max(22, max(len(x["vr"]) for x in disp))
    if_w = max(14, max(len(x["iface"]) for x in disp))
    zn_w = max(14, max(len(x["zone"]) for x in disp))
    header = f"{'Firewall':<{fw_w}} {'Mgmt IP':<{ip_w}} {'VR':<{vr_w}} {'Interface':<{if_w}} {'Zone':<{zn_w}} Error"
    sep    = "-" * (fw_w + ip_w + vr_w + if_w + zn_w + len(" Error") + 4)
    lines  = [header, sep]
    for x in disp:
        lines.append(f"{x['fw']:<{fw_w}} {x['ip']:<{ip_w}} {x['vr']:<{vr_w}} {x['iface']:<{if_w}} {x['zone']:<{zn_w}} {x['err']}")
    return lines

def main():
    ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    results_path = os.path.join(LOG_DIR, f"results_{ts}.txt")

    print(f"\n=== PAN Lookup (IPs + Name prefixes) ===")
    print(f"Panorama: {PANORAMA_HOST}")
    print(f"IPs: {', '.join(IPS_TO_CHECK) or '<none>'}")
    print(f"Name prefixes: {', '.join(NAMES_TO_CHECK) or '<none>'}")
    print(f"Logs dir: {os.path.abspath(LOG_DIR)}\n")

    pano = connect_panos(PANORAMA_HOST, "Panorama")

    # VR map from Panorama templates
    fw_to_vrs = build_fw_to_vrs_from_panorama(pano)

    # Collect context per IP; also expand names -> objects/groups -> IPs/rules
    all_ips = set(IPS_TO_CHECK)
    ip_ctx  = {}         # ip -> {"objs":[...], "refs":[...], "stars": set()}
    name_ctx = []        # for report: [{'base', 'objects':[], 'groups':[], 'rules':[]}, ...]

    # Seed ctx for existing IPs
    for ip in list(all_ips):
        objs = pano_addr_objs_for_ip(pano, ip)
        refs = []
        for o in objs:
            refs.extend(pano_rules_for_token(pano, o["name"]))
        stars = starred_fw_ips_from_dgs(dgs_for_rule_refs(refs))
        ip_ctx[ip] = {"objs": objs, "refs": refs, "stars": stars}

    # Process name prefixes
    for base in NAMES_TO_CHECK:
        found = pano_find_by_name_prefix(pano, base)
        objs = found["objects"]
        groups = found["groups"]

        # rules for *both* object names and group names
        tokens = [o["name"] for o in objs] + [g["name"] for g in groups]
        rule_refs = []
        seen_tok = set()
        for t in tokens:
            if t in seen_tok: continue
            seen_tok.add(t)
            rule_refs.extend(pano_rules_for_token(pano, t))
        name_ctx.append({"base": base, "objects": objs, "groups": groups, "rules": rule_refs})

        # add IPs from objects into the per-firewall pipeline
        for o in objs:
            ip = o.get("ip")
            if ip:
                all_ips.add(ip)

    # ensure ctx for *all* IPs we’ll check
    for ip in all_ips:
        if ip in ip_ctx:
            # augment with any additional rule refs that mention the same tokens
            continue
        objs = pano_addr_objs_for_ip(pano, ip)
        refs = []
        for o in objs:
            refs.extend(pano_rules_for_token(pano, o["name"]))
        stars = starred_fw_ips_from_dgs(dgs_for_rule_refs(refs))
        ip_ctx[ip] = {"objs": objs, "refs": refs, "stars": stars}

    pano.disconnect()

    # Firewalls: one session each; run for ALL IPs
    all_ips_list = sorted(all_ips)
    fw_results_all = {}
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as ex:
        futures = {ex.submit(fw_worker_all_ips, fw_ip, fw_name, all_ips_list, fw_to_vrs.get(fw_ip, [])): (fw_ip, fw_name)
                   for fw_ip, fw_name in FIREWALLS.items()}
        for fut in as_completed(futures):
            fw_ip, fw_name = futures[fut]
            try:
                fw_results_all[fw_ip] = fut.result()
            except Exception as e:
                fw_results_all[fw_ip] = {ip: [{"fw": fw_name, "ip": fw_ip, "vr": "<error>",
                                               "iface": "<error>", "zone": "<error>", "err": str(e)}]
                                         for ip in all_ips_list}

    # Make sure every FW appears
    for fw_ip, fw_name in FIREWALLS.items():
        if fw_ip not in fw_results_all:
            fw_results_all[fw_ip] = {ip: [{"fw": fw_name, "ip": fw_ip, "vr": "<n/a>",
                                           "iface": "<n/a>", "zone": "<n/a>", "err": "no data"}]
                                     for ip in all_ips_list}

    # Build report
    lines = []

    # Name-based section (what names/groups matched)
    if NAMES_TO_CHECK:
        lines.append("=== Name-based matches ===")
        for entry in name_ctx:
            base = entry["base"]
            lines.append(f"\n[ Base: {base} ]")
            if entry["objects"]:
                lines.append("  Address objects:")
                for o in entry["objects"]:
                    ip = o.get("ip", "<no-ip>")
                    lines.append(f"    - {o['name']}  ({o['scope']})  ip={ip}")
            else:
                lines.append("  Address objects: <none>")

            if entry["groups"]:
                lines.append("  Address-groups containing those names:")
                for g in entry["groups"]:
                    lines.append(f"    - {g['name']}  ({g['scope']})")
            else:
                lines.append("  Address-groups: <none>")

            if entry["rules"]:
                lines.append("  Rules referencing object/group names:")
                seen = set()
                for r in entry["rules"]:
                    key = (r['obj'], r['dg'], r['where'], r['rule'], r['field'])
                    if key in seen: continue
                    seen.add(key)
                    lines.append(f"    - OBJ={r['obj']:<24} DG={r['dg']:<14} {r['where']:<12} rule={r['rule']:<40} field={r['field']}")
            else:
                lines.append("  Rules referencing object/group names: <none>")

    # Per-IP sections (includes IPs derived from names)
    for ip in all_ips_list:
        ctx = ip_ctx.get(ip, {"objs": [], "refs": [], "stars": set()})
        lines.append(f"\n===== IP: {ip} =====")
        if ctx["objs"]:
            lines.append("Address object(s):")
            for o in ctx["objs"]:
                lines.append(f"  - {o['name']} ({o['scope']})")
        else:
            lines.append("Address object(s): <none found>")

        if ctx["refs"]:
            lines.append("Rules referencing the object name(s):")
            seen = set()
            for r in ctx["refs"]:
                key = (r['obj'], r['dg'], r['where'], r['rule'], r['field'])
                if key in seen: continue
                seen.add(key)
                lines.append(f"  - OBJ={r['obj']:<24} DG={r['dg']:<14} {r['where']:<12} rule={r['rule']:<40} field={r['field']}")
        else:
            lines.append("Rules referencing the object name(s): <none>")

        # flatten FW rows for this IP
        flat_rows = []
        for fw_ip, fw_name in FIREWALLS.items():
            rows = fw_results_all.get(fw_ip, {}).get(ip, [])
            if not rows:
                rows = [{"fw": fw_name, "ip": fw_ip, "vr": "<n/a>", "iface": "<n/a>", "zone": "<n/a>", "err": "no data"}]
            flat_rows.extend(rows)

        lines.append("Per-firewall routing & zone (ALL FWs; ★ = DG has matching rules; one line per VR):")
        lines.extend(format_table(flat_rows, ctx["stars"]))

    # Save + print
    ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    out_path = os.path.join(LOG_DIR, f"results_{ts}.txt")
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")

    print("\n".join(lines))
    print(f"\nSaved stitched report: {os.path.abspath(out_path)}")
    print("Legend: ★ = firewall's DG has rules referencing the IP's address object(s)\n")

if __name__ == "__main__":
    main()
